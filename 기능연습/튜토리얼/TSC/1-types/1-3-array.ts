{
  // Array
  // 배열의 타입을 정의하는 방법은 2가지가 존재함: 1) (배열 원소 타입)[], 2) Array<배열 원소 타입>
  const fruits: string[] = ['apple', 'banana'];
  const nums: Array<number> = [1, 3, 6];
  // 뭐가 더 낫고 뒤떨어지는건 없음. 단, 차이점은 존재
  /**
    ### 차이점 ###
    배열을 인수로 받아서 그대로 출력하는 함수가 있다고 할 때, 코드에 따라서는 input 배열을 수정하지 않고 단순히 출력 기능만 수행해야 하는 경우가 있음
      => 타입 설정 시점에 readonly를 같이 작성해주면 해당 함수는 인수로 전달되는 배열을 읽을 수만 있고 수정은 불가능.
    이 readonly는 오직 (배열 원소 타입)[] 형태의 타입에서만 사용할 수 있음

    readonly는 상당히 자주 사용되기 때문에, 코드 통일성 때문에라도 (배열 원소 타입)[] 형태로 배열의 타입을 설정하길 추천함
   */
  function printArray(fruits: readonly string[]) {}

  // Tuple
  // 배열이되, 서로 다른 타입의 원소를 담을 수 있는 배열
  // 타입 설정 방법: 식별자: [원소로 담을 타입을 전부 작성]
  let student: [string, number]; // 이제 이 튜플에는 string, number 타입 데이터를 모두 담을 수 있음
  student = ['name', 123];
  // 사용 방법 자체는 타입 지정을 빼면 오히려 JS의 배열과 더 유사함
  student[0] // name => 인덱스로 데이터 출력하는 것 또한 같음
  /**
    단, Tuple의 사용이 권장되지는 않음

    이유: 인덱스 방식으로 데이터를 사용하는 것은 매우 불편함
      -> 데이터가 적으면 모르겠는데, 데이터의 수가 많아지면 배열을 직접 확인하지 않고서는 올바른 데이터를 찾기가 힘듦

    만약 Tuple을 사용해야 하는 경우가 있다면, Tuple을 그대로 사용하는 대신 interface, type alias, class 등을 대신 사용할 것을 권장함

    혹은, object destructuring을 사용해서 필요한 데이터만 뽑아 쓸 수 있지만, 데이터의 저장 시점에 정해진 이름이 아니라 사용 시점에 이름을 정한 후 사용해야 하기 때문에 여전히 한계 존재
    ex) const [name, age] = student;

    튜플 사용 예제: 리액트의 useState -> 파일 위치를 확인하면 useState의 리턴 타입 자체가 튜플로 설정됨
      => 무언가를 동적으로 리턴하는 상황 + class 혹은 interface로 묶기 애매 + 관련된 다른 타입의 데이터들을 묶어서 사용자가 이름을 정해 사용하는 경우에는 튜플 사용
      -> 그 외엔 다른걸로 대체해서 사용 권장
   */
}
